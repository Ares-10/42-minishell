# 0711 해야할것: 다중 파이프 구현

# 다중파이프의 waitpid를 어떻게 관리할 것인가? ✔️
- 파이프의 개수를 구조체에 담고, 마지막 파이프 내부 커맨드 실행 후, 
  waitpid를 파이프의 개수만큼 실행한다.

void set_wpid_status(int status)
{
    // 정상 종료일 경우, 종료 코드를 g_global.rtn에 설정
    g_global.rtn = WEXITSTATUS(status);

    // 비정상 종료일 경우, 신호에 따른 처리
    if (WTERMSIG(status))
    {
        if (WTERMSIG(status) == SIGINT)
            g_global.rtn = 130;  // SIGINT 신호로 종료된 경우
        else if (WTERMSIG(status) == SIGQUIT)
            g_global.rtn = 131;  // SIGQUIT 신호로 종료된 경우
        else
            g_global.rtn = 128 + status;  // 기타 신호로 종료된 경우
    }
}

# AST에서 파이프 노드를 만나면 해야할 일 ✔️
	뒤에 파이프가 없다면 1로 리다이렉팅,
	뒤에 파이프가 있다면 파이프의 write로 리다이렉팅.
	앞에 파이프가 있었다면 그건 어차피 항상 0으로 왔을거라 알바 아님.
	N개의 파이프가 새로 파이프를 만들기보다 파이프끼리 파이프를 공유해서
	사용할 수 있어야 함. 공유 파이프를 어떻게 전달할 것인가?
	포크를 떠서 프로세스 종료시까지 기다려야한다.
	그건 여기서 하지 말고, cmd 노드에서 포크 뜨고 실행시키는걸로 하자!
	왜냐면 포크를 뜨는 순간 프로세스가 복제가 되서 노드를 중복 순회할 수도.

	마지막 파이프일 경우(뒤에 파이프가 없다면)
		마지막 커맨드를 실행시키고 나서, 기다린다.

# export 시 env ✔️
원래 환경변수가 동적할당 된거 같지 않은데..
환경변수를 그대로 복제해서 패스해준다고 가정해야겠다..
그럼 free가 가능해지니까. 보니까 이미 다 복제떠서 주셨었다.. 해결.

# 환경변수 ✔️
 $? 를 환경변수라고 생각해서 ?=저장해놓는게 일반적인 방식이더라고.

# 해결된 문제들
  1. 다중파이프일 때, waitpid를 걸어놓으니까 무한로딩이 되서 안죽는다. 왜지..?
  2. 그러니 파이프가 제대로 구현되어있는지도 확인이 불가능하다. 
  3. 우연히 grep "a" < input | grep "a" 
  를 돌렸더니 무한루프가 아니라 잘 종료되는걸 확인했다.
  문제는 제대로 출력이 안된다. 아무래도 리다이렉팅이 안되는것 같다. 로직에서의 문제를 찾아보자!

# 파이프 로직 ✔️
  Q. ls -l | cat | grep "a"
  ls -l
    R: 0
    W: 1이 아니라 pipe(w)로 리다이렉팅
    **부모는: 기존 파이프들 닫고, 뉴파이프(r)로 리다이렉팅을 해놓는다.
  cat
    R: 0이 아니라 pipe(r)로 리다이렉팅 > red있으면 다시 변경!
      질문: 만약 cat에 < a가 있었다면? a로 부터 받는다. 파이프 무시됨.
      예시:
      bash-3.2$ echo "a is hi" > a
      bash-3.2$ echo "b is hi" > b
      bash-3.2$ cat b | cat < a
      a is hi
      내 로직은 리다이렉팅이 먼저 처리되고, 파이프를 받는 구조라, 파이프가 우선순위상 더 위일 수 밖에 없다.
      그래서 다들, input_fd와 output_fd를 들고 다녔던거구나..
      아니면.. 파이프 리다이렉팅을 그냥 커맨드 끝나면 미리 다 처리해버리면 안되나..?
      그니까 전 커맨드 포크뜰 때 else문에서 미리 리다이렉팅을 해주는거지 ㅋㅋ
    W: 뒤에 파이프가 있다면 : 1이 아니라 newpipe(w)로 해야함.
        + 기존파이프 두개 닫고, 새로운 파이프를 저장해야한다.
       뒤에 파이프가 없다면 : 표준출력
    부모는: 기존 파이프들 닫고, 뉴파이프(r)로 리다이렉팅을 해놓는다.
  결론:
  커맨드를 실행한다.
  뒤에 파이프가 있다면, 미리 파이프R로 STDIN을리다이렉팅을 해준다!
  확인해보니 제대로 된다!

# 미해결 문제들
 히어독 여러개
 exit_status 제대로 처리 안됨

# here_doc 여러개 처리
  원래 로직의 문제 : 한번 히어독을 하고 나면, input이 tmp file로 리다이렉팅 되어 있어서
  두번째 히어독이 표준입력에서 받는게 아니라 처음의 tmp file에서 입력을 받게 된다. 
  그럼 어떻게 해줘야 하는가..? 같은 tmp 파일에 뒤덮어 쓰되, 
  마지막 히어독이었을 경우, 끝나고 나면, 마지막 히어독에서 리다이렉팅을 해주는 방식! + tmp 삭제!
  

# exit_status 처리
  빌트인 함수일 경우, exit status 처리를 안해줬다. 파이프를 통해 execve 되는 친구들만 반영이 되어버렸다.
  이건.. 어떻게 처리해줘야될까..

# exit status를 어떻게 관리할 것인가? 
- waitpid 내부에 status 변수를 활용한다. 
- true의 exit status는 0, false의 exit status 는 1임. 
  true | echo $? 를 하면 당연히 0, false | echo $? 를 하면 당연히 1이 나올 줄 알았지만, 
  이럴 경우 echo $? 자체가 파이프라인의 마지막 커맨드가 되어서 자기자신의 exit status를 출력하게 된다고 한다.
  하지만 내 로직은 커맨드 실행 이후에 waitpid를 하면서 exit status를 업데이트하는 것이기 때문에, 
  어떻게 해야할지 모르겠다.. 

# waitpid 하는 부분
  생각해보니까.. 만약 파이프의 마지막 함수가 빌트인이었다면, 그전 함수들에 대해서 waitpid를 하지 않고 종료가 되게 된다.
  이거 수정필요하다.

## 에러 목록
# 다중 파이프 이상하다. (해결함)
[minishell] % ls -l | ls | ls
Libft           minishell.h
Makefile        parse
error.c         prompt.c
error.o         prompt.o
main.c          run
main.o          signal.c
minishell       signal.o
[minishell] % Libft
bash: Libft
: command not found[minishell] % Makefile
bash: Makefile
: command not found[minishell] % error.c
bash: error.c
: command not found[minishell] % error.o
bash: error.o
: command not found[minishell] % main.c
bash: main.c
: command not found[minishell] % main.o
bash: main.o
: command not found[minishell] % minishell
Error
tcgetattr failed
[minishell] % minishell.h
bash: minishell.h
: command not found[minishell] % parse
bash: parse
: command not found[minishell] % prompt.c
bash: prompt.c
: command not found[minishell] % prompt.o
bash: prompt.o
: command not found[minishell] % run
bash: run
: command not found[minishell] % signal.c
bash: signal.c
: command not found[minishell] % signal.o
bash: signal.o
: command not found[minishell] % exit

생각해보니까, 이게 계속 돌아갈 때마다 표준 입출력을 다시 리세팅 해줘야되는구나..! 깨달았다.