# 0711 해야할것: 다중 파이프 구현

# 다중파이프의 waitpid를 어떻게 관리할 것인가? ✔️
- 파이프의 개수를 구조체에 담고, 마지막 파이프 내부 커맨드 실행 후, 
  waitpid를 파이프의 개수만큼 실행한다.

void set_wpid_status(int status)
{
    // 정상 종료일 경우, 종료 코드를 g_global.rtn에 설정
    g_global.rtn = WEXITSTATUS(status);

    // 비정상 종료일 경우, 신호에 따른 처리
    if (WTERMSIG(status))
    {
        if (WTERMSIG(status) == SIGINT)
            g_global.rtn = 130;  // SIGINT 신호로 종료된 경우
        else if (WTERMSIG(status) == SIGQUIT)
            g_global.rtn = 131;  // SIGQUIT 신호로 종료된 경우
        else
            g_global.rtn = 128 + status;  // 기타 신호로 종료된 경우
    }
}

# 미해결 문제들
 히어독 여러개
 exit_status 제대로 처리 안됨

# here_doc 여러개 처리
  원래 로직의 문제 : 한번 히어독을 하고 나면, input이 tmp file로 리다이렉팅 되어 있어서
  두번째 히어독이 표준입력에서 받는게 아니라 처음의 tmp file에서 입력을 받게 된다. 
  그럼 어떻게 해줘야 하는가..? 같은 tmp 파일에 뒤덮어 쓰되, 
  마지막 히어독이었을 경우, 끝나고 나면, 마지막 히어독에서 리다이렉팅을 해주는 방식! + tmp 삭제!

# exit_status 처리
  빌트인 함수일 경우, exit status 처리를 안해줬다. 파이프를 통해 execve 되는 친구들만 반영이 되어버렸다.
  이건.. 어떻게 처리해줘야될까..

# exit status를 어떻게 관리할 것인가? 
- waitpid 내부에 status 변수를 활용한다. 
- true의 exit status는 0, false의 exit status 는 1임. 
  true | echo $? 를 하면 당연히 0, false | echo $? 를 하면 당연히 1이 나올 줄 알았지만, 
  이럴 경우 echo $? 자체가 파이프라인의 마지막 커맨드가 되어서 자기자신의 exit status를 출력하게 된다고 한다.
  하지만 내 로직은 커맨드 실행 이후에 waitpid를 하면서 exit status를 업데이트하는 것이기 때문에, 
  어떻게 해야할지 모르겠다.. 

# 알게 된 것
1. 클러스터 맥에서 brew 설치:
rm -rf $HOME/.brew && git clone --depth=1 https://github.com/Homebrew/brew $HOME/.brew && echo 'export PATH=$HOME/.brew/bin:$PATH' >> $HOME/.zshrc && source $HOME/.zshrc && brew update

# 에러처리
1. echo -n 옵션이 안들어간다.


# 테스트 해볼만한 것
echo hello
echo -n hello
echo -nnnnn -n -nnnn hello -n
echo -nnnnnnnm hello
echo hello -n
=통과

exit
exit 100
exit hello
=불통

"pwd"
"ls"
"echo"
echo "hello       world"env
쌍따옴표 통과

'ls' > 가끔 엔터키 넣어서 입력하면 망함. 
''
echo '$USER'
echo '$HOME   dd'
따옴표 한개 'ls'