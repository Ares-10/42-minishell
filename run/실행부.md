# 0차: AST에서 파이프 노드를 만나면 하는 일 ✔️
  뒤에 파이프가 있는지 여부를 확인해서 기록해둔다.
  파이프로의 입출력 리다이렉팅은 하지 않는다.

# 1차: AST에서 파이프 노드를 만나면 하는 일 ✔️
  1) 뒤에 파이프가 있는지 여부를 확인해서 기록해둔다. (필요한지 모르겠음)
  2) 파이프 만들고, 입출력 리다이렉팅!
    Q. 파이프노드에서 입출력 바꾸면.. 후에 리다이렉팅이 왔을 경우?
    A. 파이프노드에서 미리 바꾸는게 맞는 로직이었다.
      [ 입력 우선순위 ]
      전 파이프에서 받은 입력 / heredoc or file input
      리다이렉션은 항상 가장 마지막에 온 친구가 들어가게 된다.
      파이프 > 히어독 > 파일입력 순이라면, 파일 입력임..!
      [ 출력 우선순위 ]
      파일 출력, 파이프 출력 ? 파일 출력이 먼저다. 
      로직상: 파이프로 출력 변경 > 리다이렉션 변경 이 맞는 로직이다.

# 0차: AST에서 커맨드 노드를 만나면 해야할 일 ✔️
  [출력]
	뒤에 파이프가 없다면 1로 리다이렉팅,
	뒤에 파이프가 있다면 파이프의 write로 리다이렉팅.
  [입력]
	앞에 파이프가 있었다면 그건 어차피 항상 0으로 왔을거라 알바 아님.
	N개의 파이프가 새로 파이프를 만들기보다 파이프끼리 파이프를 공유해서
	사용할 수 있어야 함. 공유 파이프를 어떻게 전달할 것인가?
	포크를 떠서 프로세스 종료시까지 기다려야한다.
	그건 여기서 하지 말고, cmd 노드에서 포크 뜨고 실행시키는걸로 하자!
	왜냐면 포크를 뜨는 순간 프로세스가 복제가 되서 노드를 중복 순회할 수도.

	마지막 파이프일 경우(뒤에 파이프가 없다면)
		마지막 커맨드를 실행시키고 나서, 기다린다.
  
## X문제1: 빌트인 함수가 마지막일 경우, waitpid하는 로직이 없어진다.
## O문제2: 빌트인 함수들이 파이프로 출력을 못한다.
  꼭 포크를 뜨고 리다이렉팅을 해야할까?


# 다중파이프의 waitpid를 어떻게 관리할 것인가? ✔️
- 파이프의 개수를 구조체에 담고, 마지막 파이프 내부 커맨드 실행 후, 
  waitpid를 파이프의 개수만큼 실행한다.

void set_wpid_status(int status)
{
    // 정상 종료일 경우, 종료 코드를 g_global.rtn에 설정
    g_global.rtn = WEXITSTATUS(status);

    // 비정상 종료일 경우, 신호에 따른 처리
    if (WTERMSIG(status))
    {
        if (WTERMSIG(status) == SIGINT)
            g_global.rtn = 130;  // SIGINT 신호로 종료된 경우
        else if (WTERMSIG(status) == SIGQUIT)
            g_global.rtn = 131;  // SIGQUIT 신호로 종료된 경우
        else
            g_global.rtn = 128 + status;  // 기타 신호로 종료된 경우
    }
}

# 미해결 문제들
 히어독 여러개
 exit_status 제대로 처리 안됨

# here_doc 여러개 처리
  원래 로직의 문제 : 한번 히어독을 하고 나면, input이 tmp file로 리다이렉팅 되어 있어서
  두번째 히어독이 표준입력에서 받는게 아니라 처음의 tmp file에서 입력을 받게 된다. 
  그럼 어떻게 해줘야 하는가..? 같은 tmp 파일에 뒤덮어 쓰되, 
  마지막 히어독이었을 경우, 끝나고 나면, 마지막 히어독에서 리다이렉팅을 해주는 방식! + tmp 삭제!

# exit_status 처리
  빌트인 함수일 경우, exit status 처리를 안해줬다. 파이프를 통해 execve 되는 친구들만 반영이 되어버렸다.
  이건.. 어떻게 처리해줘야될까..

# exit status를 어떻게 관리할 것인가? 
- waitpid 내부에 status 변수를 활용한다. 
- true의 exit status는 0, false의 exit status 는 1임. 
  true | echo $? 를 하면 당연히 0, false | echo $? 를 하면 당연히 1이 나올 줄 알았지만, 
  이럴 경우 echo $? 자체가 파이프라인의 마지막 커맨드가 되어서 자기자신의 exit status를 출력하게 된다고 한다.
  하지만 내 로직은 커맨드 실행 이후에 waitpid를 하면서 exit status를 업데이트하는 것이기 때문에, 
  어떻게 해야할지 모르겠다.. 


# 테스트 불통

exit
exit 100
exit hello
=불통

'ls' > 가끔 엔터키 넣어서 입력하면 망함. 

# dup2
- 매뉴얼이 리눅스버전은 또 다른데, 찾아보니 이해가 더 잘된다.
dup2(int oldfd, int newfd)
oldfd가 가리키는것을 newfd가 동일하게 가리킬 수 있도록 해준다고 한다.


## 잡다한 알게 된 것
# 클러스터 맥에서 brew 설치:
rm -rf $HOME/.brew && git clone --depth=1 https://github.com/Homebrew/brew $HOME/.brew && echo 'export PATH=$HOME/.brew/bin:$PATH' >> $HOME/.zshrc && source $HOME/.zshrc && brew update

# makefile 경로 찾기
brew --prefix readline