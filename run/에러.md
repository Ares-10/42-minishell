# 사소한 에러
# 에러1: wrong command input이 아닌데 뜸
[minishell] % < input
Error
wrong cmd input

bash-3.2$ < input
bash-3.2$

[minishell] % << end1 <<end2 | cat
Error
wrong cmd input

[minishell] % < a cat
Error
wrong cmd input

# 에러2: 커맨드 뒤에 빈 문자열 입력했을 경우 argv 문제
### 수정 완료 - hyungcho
ls                      (빈 문자열)
입력시 argv에 , , 빈 문자열이 하나 추가로 들어가게 됨.

# 에러3: env는 인자 없어서, 구분자 없어도 뒤에 커맨드 와도 됨.
### 수정 완료 - hyungcho
- env 가 뒤에 커맨드에 씹혀야함.
bash-3.2$ env echo "hi"
hi
[minishell] % env echo "hi"
T_PIPE
T_CMD
T_REDIRECTS
T_SIMPLECMD     | file_path: env | argv: env, echo, hi, (null)

# 에러4: 세미콜론 처리가 안됨.
### 수정 완료 - hyungcho
서브젝트: Not interpret unclosed quotes or special characters which are not required by the
subject such as \ (backslash) or ; (semicolon).
예시: 
[minishell] % echo a; echo b;
T_PIPE
T_CMD
T_REDIRECTS
T_SIMPLECMD     | file_path: echo | argv: echo, a;, echo, b;, (null)
a; echo b;

# 심각한 에러
# 수정완료_에러1: env에 대해 grep이 적용되지 않는다.
	- 참고: 이상한건, cat input | grep apple 이런것들에 대해서는 된다.
	- 원인분석: 아무래도, 빌트인 함수들은 파이프처리가 안되어서 이런 현상이 일어나는것 같다. 
	- 파이프 노드에서 pipe(fd)를 떠주고 그값을 저장한 구조체를 사용해서 인풋과 아웃풋을 각 명령어에서 리다이렉팅 해야겠다. 

bash-3.2$ env | grep XPC_FLAGS
XPC_FLAGS=0x0

[minishell] % env | grep XPC_FLAGS
env가 그대로 나옴.

# 수정완료_에러2: unset PATH 하고 나서 아무런 커맨드도 작동하지 않음.

# 에러3: 파이프 에러
< main.c env env ls > test2 -a | env env head -3
이렇게 쉘에 입력했을 때 bashshell, minishell 모두 ls 명령의 결과가 test2 파일에 들어가는 것까지는 똑같이 동작하지만,
bashshell 에서는 터미널에 ls head -3의 결과가 출력되는 데 비해 minishell에서는 ls head -3의 결과가 출력되지 않았습니다.
